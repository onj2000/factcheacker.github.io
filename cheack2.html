<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SNSコメントリスク分析ツール</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 日本語フォントと全体の背景 */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;600;700&display=swap');
    body {
      font-family: 'Inter', 'Noto Sans JP', sans-serif;
      background-color: #f7f9fb;
    }
    .container-box { box-shadow: 0 10px 30px rgba(0,0,0,0.08); }

    /* --- カスタムリンクスタイル (青い下線付き) --- */
    .custom-link {
      color: #1e40af; /* blue-700 */
      text-decoration: none;
      font-weight: 500;
      padding-bottom: 2px;
      position: relative;
      transition: color 0.3s ease;
      display: inline-block;
    }
    .custom-link::after {
      content: '';
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 2px;
      background-color: #3b82f6; /* blue-500 */
      transition: height 0.3s ease, background-color 0.3s ease;
    }
    .custom-link:hover { color: #1d4ed8; }
    .custom-link:hover::after {
      height: 4px;
      background-color: #1e40af;
    }
    /* --- 分類タグのスタイル --- */
    .classification-tag {
      padding: 4px 12px;
      border-radius: 9999px;
      font-weight: 600;
      font-size: 0.875rem;
      display: inline-block;
      min-width: 100px;
      text-align: center;
    }
    .color-safe { background-color: #dcfce7; color: #166534; }
    .color-slander { background-color: #fef9c3; color: #854d0e; }
    .color-false { background-color: #ffedd5; color: #9a3412; }
    .color-crime { background-color: #fee2e2; color: #991b1b; }
    .color-bot { background-color: #f3e8ff; color: #6b21a8; }
    .color-unknown { background-color: #e5e7eb; color: #4b5563; }

    /* ローダー */
    .loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3b82f6;
      border-radius: 50%;
      width: 24px; height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
  </style>
</head>
<body class="p-4 sm:p-8 min-h-screen">
  <div class="max-w-4xl mx-auto w-full">

    <header class="mb-8 text-center">
      <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">SNSコメント リスク分析ツール</h1>
      <p class="text-gray-600">AIを使い、コメントを危険度別に分類し、論調（感情的/論理的）を分析します。</p>
    </header>

    <!-- APIキーとコストの説明 -->
    <details class="bg-red-50 border border-red-300 p-6 rounded-xl mb-8 container-box">
      <summary class="text-lg font-bold text-red-800 cursor-pointer">⚠️ APIキーの取得、コスト、セキュリティについて</summary>
      <div class="mt-4 space-y-4 text-gray-700 border-t border-red-300 pt-4">
        
        <h3 class="text-xl font-semibold text-green-700">✅ 無料利用枠について (重要)</h3>
        <ul class="list-disc ml-4 space-y-2">
            <li>**AIプラットフォーム:** ほとんどのAIプラットフォームには、**新規ユーザー向けの無料利用枠**があります。まずは無料でテストを開始できます。</li>
            <li>ただし、無料枠を超えると**自動的に従量課金**に移行します。必ず次の「コストと課金」の項目を確認し、利用制限を設定してください。</li>
        </ul>

        <h3 class="text-xl font-semibold text-red-800 pt-4">🚨 コストと課金に関する重要事項</h3>
        <ul class="list-disc ml-4 space-y-2">
            <li>**従量課金制:** Google Gemini API、OpenAI APIはすべて従量課金制です。分析を実行するたびに、コメントの文字数に応じて費用が発生します。</li>
            <li>**利用制限の設定:** 予期せぬ高額請求を防ぐため、**必ず各プラットフォーム（Google CloudまたはOpenAI Platform）で利用制限（Billing Limit）を設定**してください。</li>
            <li>**コスト効率の選択肢:** **Gemini 2.5 Flash-Lite**と**GPT-4o mini**が、現在最も低コストで利用できる高性能モデルです。</li>
        </ul>

        <h3 class="text-xl font-semibold text-gray-800 pt-4">🌐 Google Gemini (推奨)</h3>
        <p class="text-sm">Geminiモデルを選択すると、**Web参照機能**により最新情報を参照して分析できますが、**構造化出力との両立のため、正式な情報源は表示されません**。</p>
        <ul class="list-disc ml-4">
          <li>キー発行: <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank" class="custom-link">Google AI Studio (APIキーページ)</a></li>
          <li>料金詳細: <a href="https://ai.google.dev/pricing" target="_blank" class="custom-link">Google AI 価格ページ</a></li>
        </ul>

        <h3 class="text-xl font-semibold text-gray-800 pt-4">💻 GPT (OpenAI)</h3>
        <ul class="list-disc ml-4">
          <li>キー発行: <a href="https://platform.openai.com/account/api-keys" target="_blank" class="custom-link">OpenAI Platform (APIキーページ)</a></li>
          <li>料金詳細: <a href="https://openai.com/pricing" target="_blank" class="custom-link">OpenAI 価格ページ</a></li>
        </ul>
        
        <h3 class="text-xl font-semibold text-red-800 pt-4">セキュリティ上の注意</h3>
        <p class="text-sm font-bold">このツールはブラウザ上でAPIキーを直接使用します。キーの管理には十分注意し、分析が終了したらすぐにキーを削除してください。</p>
      </div>
    </details>

    <!-- 設定と入力 -->
    <div class="bg-white p-6 sm:p-8 rounded-xl container-box mb-8">
      <h2 class="text-xl font-bold text-gray-800 mb-4">分析設定と入力</h2>

      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
          <div>
            <label for="model-select" class="block text-sm font-semibold text-gray-700 mb-2">AIモデルを選択</label>
            <select id="model-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
              <option value="gemini-flash">Google Gemini 2.5 Flash (高性能)</option>
              <option value="gemini-lite" selected>Google Gemini 2.5 Flash-Lite (最安価)</option>
              <option value="openai">OpenAI GPT-4o mini (最安価)</option>
            </select>
          </div>
          <div>
            <label id="key-label" for="api-key-input" class="block text-sm font-semibold text-gray-700 mb-2">APIキー</label>
            <input id="api-key-input" type="password" placeholder="AIzで始まるキーを入力" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
          </div>
      </div>

      <label class="block text-lg font-semibold text-gray-700 mb-3 mt-4">分析したいSNSコメントを入力してください</label>
      <textarea id="comment-input" rows="4" class="w-full p-4 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" placeholder="例: あの会社は明日倒産する。これは内部情報だ。"></textarea>

      <button id="analyze-button" onclick="analyzeComment()" class="mt-4 w-full px-6 py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition duration-150 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
        <div id="button-text">コメントを分析する</div>
        <div id="loading-spinner" class="hidden loader ml-2"></div>
      </button>
    </div>

    <!-- 結果 -->
    <div id="results-area" class="hidden bg-white p-6 sm:p-8 rounded-xl container-box">
      <h2 class="text-2xl font-bold text-gray-800 mb-4">分析結果</h2>
      
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
        <div class="flex items-center">
          <span class="text-gray-600 font-medium mr-4 text-lg">分類:</span>
          <span id="classification-display" class="classification-tag"></span>
        </div>
        <div class="flex items-center">
          <span class="text-gray-600 font-medium mr-4 text-lg">論調:</span>
          <span id="argument-type-display" class="font-bold text-lg text-gray-900 bg-gray-100 p-2 rounded-lg text-center w-full"></span>
        </div>
      </div>
      
      <div class="mb-6">
        <h3 class="text-xl font-semibold text-gray-700 mb-2">根拠・分析</h3>
        <div id="reasoning-display" class="text-gray-800 p-4 bg-gray-50 rounded-lg border border-gray-200 whitespace-pre-wrap"></div>
      </div>
      
      <!-- 情報源エリア (構造化出力優先のため、ファクトチェック機能は非使用) -->
      <div id="sources-container" class="hidden mt-4 pt-4 border-t border-gray-200">
        <h3 class="text-xl font-semibold text-gray-700 mb-2 flex items-center">
            <svg class="w-5 h-5 mr-1 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.27a1 1 0 01.112.181l.088.22a1 1 0 01.037.289v9.544a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h7.828a1 1 0 01.707.293l3.586 3.586a1 1 0 01.293.707V7z"></path></svg>
            情報源
        </h3>
        <ul id="sources-list" class="space-y-2 text-sm ml-2"></ul>
        <p class="text-xs text-gray-500 mt-2">※ 現在、JSON構造化出力との両立のため、正式な情報源の表示はできません。</p>
      </div>
    </div>

    <!-- エラー -->
    <div id="error-message" class="hidden mt-8 p-4 bg-red-100 text-red-700 border border-red-200 rounded-lg container-box">
      <span class="font-bold">エラー: </span>
      <span id="error-text"></span>
    </div>

  </div>

<script>
const MODEL_CONFIG = {
  "gemini-flash": {
    endpoint: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent",
    modelName: "gemini-2.5-flash-preview-09-2025",
    type: "gemini"
  },
  "gemini-lite": {
    endpoint: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite-preview:generateContent", // Flash-Liteのエンドポイント
    modelName: "gemini-2.5-flash-lite-preview",
    type: "gemini"
  },
  "openai": {
    endpoint: "https://api.openai.com/v1/chat/completions",
    modelName: "gpt-4o-mini", // GPTの安価モデル
    type: "openai"
  }
};

const CLASSIFICATION_MAP = {
    "犯罪助長": { color: "color-crime", display: "犯罪行為/脅迫" },
    "誹謗中傷": { color: "color-slander", display: "誹謗中傷/ハラスメント" },
    "虚偽情報": { color: "color-false", display: "フェイクニュース/誤情報" },
    "自動投稿（bot）": { color: "color-bot", display: "Bot/自動生成" },
    "安全": { color: "color-safe", display: "安全/問題なし" },
    "不明": { color: "color-unknown", display: "不明/解析不能" }
};

// --- DOM要素 ---
const modelSelect = document.getElementById('model-select');
const apiKeyInput = document.getElementById('api-key-input');
const commentInput = document.getElementById('comment-input');
const analyzeButton = document.getElementById('analyze-button');
const buttonText = document.getElementById('button-text');
const loadingSpinner = document.getElementById('loading-spinner');
const resultsArea = document.getElementById('results-area');
const classificationDisplay = document.getElementById('classification-display');
const argumentTypeDisplay = document.getElementById('argument-type-display'); 
const reasoningDisplay = document.getElementById('reasoning-display');
const sourcesContainer = document.getElementById('sources-container');
const sourcesList = document.getElementById('sources-list');
const errorMessage = document.getElementById('error-message');
const errorText = document.getElementById('error-text');
const keyLabel = document.getElementById('key-label');

// --- 初期化とイベントリスナー ---
modelSelect.addEventListener('change', updateAPIKeyPrompt);
document.addEventListener('DOMContentLoaded', updateAPIKeyPrompt);

/**
 * モデル選択時のUI表示を更新する
 */
function updateAPIKeyPrompt() {
    const modelKey = modelSelect.value;
    const config = MODEL_CONFIG[modelKey];
    const isGemini = config.type === 'gemini';
    const isCanvasAutoFilled = isGemini && typeof __initial_auth_token !== 'undefined';

    if (isGemini) {
        keyLabel.textContent = "Google Gemini APIキー";
        apiKeyInput.placeholder = isCanvasAutoFilled ? "キーを入力（空欄で自動認証を試行）" : "AIzで始まるキーを入力";
    } else {
        keyLabel.textContent = "OpenAI APIキー";
        apiKeyInput.placeholder = "sk-で始まるキーを入力";
    }

    if (apiKeyInput.value === 'CANVAS_AUTO_FILLED') {
        apiKeyInput.value = '';
    }
}

/**
 * APIキーの形式をチェックするヘルパー関数
 */
function validateApiKey(modelType, key) {
    if (modelType === 'gemini') {
        // Canvas環境の自動認証に依存する場合は空欄を許可
        if (key === '') return { valid: true }; 
        if (!key.startsWith('AIza')) {
            return { valid: false, message: "Geminiキーは通常 'AIza' で始まります。キーが正しいか確認してください。" };
        }
    } else if (modelType === 'openai') {
        if (key === '') {
             return { valid: false, message: "OpenAIモデルを使用するにはAPIキーを入力してください。" };
        }
        if (!key.startsWith('sk-')) {
            return { valid: false, message: "OpenAIキーは 'sk-' で始まります。キーが正しいか確認してください。" };
        }
    }
    return { valid: true };
}


/**
 * コメントを分析し、結果をUIに表示するメイン関数
 */
async function analyzeComment() {
  const comment = commentInput.value.trim();
  const modelKey = modelSelect.value;
  const config = MODEL_CONFIG[modelKey];
  let apiKey = apiKeyInput.value.trim();
  
  if (!comment) return showError("コメントを入力してください。");
  
  const isGemini = config.type === 'gemini';

  // 1. APIキーの検証
  const keyValidation = validateApiKey(config.type, apiKey);
  if (!keyValidation.valid) {
      return showError("APIキーの形式が間違っている可能性があります: " + keyValidation.message);
  }
  
  // 2. APIキーの設定 (Geminiの場合、空欄なら自動認証に依存)
  if (isGemini && apiKey === '') {
      console.log("Relying on Canvas environment for Gemini API Key.");
  } else if (!isGemini && apiKey === '') {
      return showError("OpenAIモデルを選択しました。APIキーを入力してください。");
  }

  setLoading(true);
  try {
    let result = null;
    let response = null;

    if (isGemini) {
        console.log(`--- Gemini API Call (Model: ${config.modelName}) ---`);
        // APIキーはクエリパラメータに設定。手動で入力されていない場合は空欄。
        const url = `${config.endpoint}?key=${apiKey}`;
        
        const body = {
            contents: [{ parts: [{ text: comment }] }],
            systemInstruction: { parts: [{ text: generateSystemPrompt(config.modelName) }] },
            // 構造化出力
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        classification: { type: "STRING" },
                        argument_type: { type: "STRING" }, 
                        reasoning: { type: "STRING" }
                    },
                    required: ["classification", "argument_type", "reasoning"] 
                }
            },
            // Web参照 (Flashモデルでのみ有効な指示を出す)
            // tools: [{ "google_search": {} }],
        };
        
        response = await fetchWithExponentialBackoff(url, {
            method: "POST", 
            headers: { "Content-Type": "application/json" }, 
            body: JSON.stringify(body)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error("Gemini HTTP Error Response:", response.status, errorText);
            
            let userMessage = `Gemini API呼び出しエラー: ステータスコード ${response.status}。`;
            if (response.status === 400) {
                 userMessage = `リクエストの形式が不正です。**Gemini APIキー、または入力内容、プロジェクトの有効化**を確認してください。サーバーからの詳細: ${errorText.substring(0, 150)}...`;
            } else if (response.status === 401 || response.status === 403) {
                userMessage += "APIキーが正しく設定されているか、または課金が有効か確認してください。";
            } else {
                 userMessage += "不明なエラーです。";
            }
            throw new Error(userMessage);
        }

        const rawData = await response.json();
        const jsonText = rawData.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!jsonText) {
            console.error("Gemini API Error: Missing JSON content in response.", rawData);
            throw new Error(rawData.error?.message || "Geminiからの応答が不正です。APIキーが有効か、課金が有効か確認してください。");
        }
        
        result = JSON.parse(jsonText);

    } else { // OpenAI
        console.log(`--- OpenAI API Call (Model: ${config.modelName}) ---`);
        const body = {
            model: config.modelName,
            messages: [{ role: "system", content: generateSystemPrompt(config.modelName) }, { role: "user", content: comment }],
            response_format: { type: "json_object" }
        };
        
        response = await fetchWithExponentialBackoff(config.endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
            body: JSON.stringify(body)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error("OpenAI HTTP Error Response:", response.status, errorText);
            let userMessage = `OpenAI API呼び出しエラー: ステータスコード ${response.status}。`;
            if (response.status === 401) {
                userMessage += "APIキーが有効ではありません。キーを確認してください。";
            }
            throw new Error(userMessage);
        }
        
        const rawData = await response.json();
        const jsonText = rawData.choices?.[0]?.message?.content;

        if (!jsonText) {
            console.error("OpenAI API Error: Missing JSON content in response.", rawData);
            throw new Error("OpenAIからの結果解析に失敗しました。APIキーが有効か、課金が有効か確認してください。");
        }
        
        // JSON以外の文字列が含まれる可能性を考慮し、JSONブロックを抽出してからパース
        let cleanedJsonText = jsonText.trim();
        if (cleanedJsonText.startsWith("```json")) {
            cleanedJsonText = cleanedJsonText.substring(7, cleanedJsonText.lastIndexOf("```")).trim();
        } else if (cleanedJsonText.startsWith("```")) { 
             cleanedJsonText = cleanedJsonText.substring(3, cleanedJsonText.lastIndexOf("```")).trim();
        }

        result = JSON.parse(cleanedJsonText);
    }

    if (!result.classification || !result.argument_type) throw new Error("結果の解析に失敗しました。classificationまたはargument_typeフィールドが見つかりません。");

    updateResultUI(result);

  } catch (err) {
    showError("分析中にエラーが発生しました: " + err.message + "。コンソール（F12）で詳細を確認してください。");
    console.error("Fatal Analysis Error:", err);
  } finally {
    setLoading(false);
  }
}

/**
 * 指数バックオフ付きフェッチ関数（レート制限対策）
 */
async function fetchWithExponentialBackoff(url, options, maxRetries = 5) {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            const response = await fetch(url, options);
            if (response.status !== 429 && response.ok) {
                return response;
            } else if (response.status === 429) {
                // Rate limit: delay and retry
                console.warn(`Rate limit hit (429). Retrying in ${Math.pow(2, attempt)}s...`);
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 500;
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                return response; // Return non-OK response for caller to handle
            }
        } catch (error) {
            if (attempt === maxRetries - 1) {
                throw error;
            }
            // Network error: delay and retry
            console.error(`Network error on attempt ${attempt + 1}. Retrying...`, error);
            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 500;
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
    throw new Error("API呼び出しが最大リトライ回数を超えました。");
}

/**
 * AIモデルに渡すシステムプロンプトを生成する
 */
function generateSystemPrompt(modelName) {
    const classifications = Object.keys(CLASSIFICATION_MAP).filter(c => c !== "不明").join('」「');

    // 論調の判別を追加し、JSON出力指示を厳格化
    let prompt = `あなたはSNSコメントを以下の分類で識別し、さらに**論調（argument_type）が「論理的」、「感情的」、または「論理的（感情的要素あり）」のいずれであるか**を判定するAIリスクアナリストです。
    
    分析結果は、**必ず**JSON形式で {"classification": "分類名", "argument_type": "論調", "reasoning": "分類の根拠と分析結果を日本語で詳細に記述してください。"} のみ返答してください。JSON以外の文章や説明は**一切**含めないでください。

    分類: 「${classifications}」のいずれかを選択すること。
    論調: 「論理的」、「感情的」、または「論理的（感情的要素あり）」のいずれかを選択すること。`;

    if (modelName === 'gemini-2.5-flash-preview-09-2025') {
        prompt += `
        分析を行う際、コメント内の事実（特に虚偽情報やフェイクニュースの可能性）を検証するため、最新の知識やWeb情報を参照し、分析結果（reasoning）に反映させてください。`;
    }
    // Flash-LiteとGPT-4o miniには、Web参照を指示しません。

    return prompt;
}

/**
 * 分析結果に基づいてUIを更新する
 * @param {object} result - 分析結果オブジェクト
 */
function updateResultUI(result) {
    const classification = result.classification || "不明";
    const argumentType = result.argument_type || "不明"; 
    const reasoning = result.reasoning || "理由が提供されませんでした。";
    const mapping = CLASSIFICATION_MAP[classification] || CLASSIFICATION_MAP["不明"];
    
    // 1. 分類タグの更新
    classificationDisplay.className = "classification-tag";
    classificationDisplay.classList.add(mapping.color);
    classificationDisplay.textContent = mapping.display;
    
    // 2. 論調の更新
    argumentTypeDisplay.textContent = argumentType;
    
    // 3. 根拠の更新
    reasoningDisplay.textContent = reasoning;
    
    // 4. 情報源の更新 (JSON構造化出力を優先するため、この機能は非表示)
    sourcesContainer.classList.add('hidden');
    sourcesList.innerHTML = '';
    
    // 5. 結果表示エリアを表示
    resultsArea.classList.remove("hidden");
    errorMessage.classList.add("hidden");
}

/**
 * エラーメッセージを表示する
 */
function showError(msg){ 
    errorText.innerHTML = msg; 
    errorMessage.classList.remove("hidden"); 
    resultsArea.classList.add("hidden");
}

/**
 * ローディング状態を切り替える
 */
function setLoading(b){ 
    analyzeButton.disabled = b; 
    loadingSpinner.classList.toggle("hidden",!b); 
    buttonText.textContent = b ? "分析中..." : "コメントを分析する"; 
}
</script>
</body>
</html>

